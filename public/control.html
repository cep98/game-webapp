<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Control</title>
  <style>
    html, body {
      margin:0; padding:0; height:100%; background:#222;
      color:#fff; font-family:sans-serif;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      -webkit-user-select:none; user-select:none;
      touch-action: none; overscroll-behavior: none;
    }
    #version { position:absolute; top:10px; right:10px; opacity:0.7; font-size:0.9em; }
    .btn {
      border:4px solid transparent; border-radius:12px;
      background:#444; width:110px; height:110px; margin:10px;
    }
    #gyroBtn { border-radius:16px; }
    #laserBtn { border-radius:50%; background:#cc0000; display:none; }
    @media (orientation: landscape) {
      body::after {
        content: "Bitte im Hochformat nutzen (Rotation gesperrt).";
        position: fixed; bottom: 12px; left: 0; right: 0;
        text-align: center; font-size: 12px; opacity: .6;
      }
    }
  </style>
</head>
<body>
  <div id="version">v2.2 Control</div>
  <button id="gyroBtn" class="btn" aria-label="Gyro erlauben"></button>
  <button id="laserBtn" class="btn" aria-label="Laser halten"></button>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket   = io();
    const gyroBtn  = document.getElementById('gyroBtn');
    const laserBtn = document.getElementById('laserBtn');

    let myColor   = null;
    let drawing   = false;
    let sentStart = false;

    // ---- Rohdaten ----
    let rawTiltX = 0, rawTiltY = 0; // aus DeviceMotion (Gravitation)
    let rawGamma = 0;               // aus DeviceOrientation (Roll)

    // ---- Gefilterte Werte (einfacher Low-Pass) ----
    let filtTiltX = 0, filtTiltY = 0, filtGamma = 0;

    // ---- Nullpunkte (beim ersten Laser-Druck) ----
    let zeroTiltX = 0, zeroTiltY = 0, zeroGamma = 0;

    // Admin-Limits (Reichweiten-Mapping)
    let maxHor = 20, maxVer = 20;

    // Fallback-Flags
    let hasMotion = false; // ob DeviceMotion brauchbar ist

    socket.on('connect', () => {
      socket.emit('identify', { role:'control', deviceId: socket.id });
      socket.emit('request-settings');
    });

    socket.on('assign-color', color => {
      myColor = color;
      laserBtn.style.borderColor = myColor;
      gyroBtn.style.borderColor  = myColor;
    });

    socket.on('settings', s => {
      if (typeof s.maxHor === 'number') maxHor = s.maxHor;
      if (typeof s.maxVer === 'number') maxVer = s.maxVer;
    });

    // Portrait-Lock (best effort)
    async function tryLockPortrait() {
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen({ navigationUI: 'hide' }).catch(()=>{});
        } else if (document.documentElement.webkitRequestFullscreen) {
          await document.documentElement.webkitRequestFullscreen();
        }
        if (screen.orientation && screen.orientation.lock) {
          await screen.orientation.lock('portrait');
        }
      } catch {}
    }
    document.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
    window.addEventListener('orientationchange', tryLockPortrait);

    // Permission + UI
    gyroBtn.addEventListener('click', async () => {
      try {
        const reqs = [];
        if (DeviceOrientationEvent?.requestPermission) {
          reqs.push(DeviceOrientationEvent.requestPermission().catch(()=> 'denied'));
        }
        if (DeviceMotionEvent?.requestPermission) {
          reqs.push(DeviceMotionEvent.requestPermission().catch(()=> 'denied'));
        }
        if (reqs.length) {
          const results = await Promise.all(reqs);
          if (results.some(r => r === 'denied')) {
            alert('Gyro-/Motion-Zugriff benötigt!');
            return;
          }
        }
        await tryLockPortrait();
        gyroBtn.style.display  = 'none';
        laserBtn.style.display = 'block';
      } catch (e) {
        alert('Sensoren nicht verfügbar.');
      }
    });

    // ---- Sensor-Leser ----
    // DeviceMotion: stabil für Neigung (keine 0/360-Sprünge)
    window.addEventListener('devicemotion', ev => {
      const g = ev.accelerationIncludingGravity;
      if (!g) return;
      // Tilt aus Gravitation (Grad)
      // tx: links/rechts, ty: vor/zurück
      const tx = Math.atan2(g.x || 0, g.z || 0) * 180 / Math.PI;
      const ty = Math.atan2(g.y || 0, g.z || 0) * 180 / Math.PI;
      // Sanfter Clamp der Rohwerte (extreme outlier weg)
      rawTiltX = Math.max(-85, Math.min(85, tx));
      rawTiltY = Math.max(-85, Math.min(85, ty));
      hasMotion = true;
    });

    // DeviceOrientation: nur für Roll (gamma), robust genug im Bereich [-90,90]
    window.addEventListener('deviceorientation', ev => {
      if (typeof ev.gamma === 'number') {
        rawGamma = Math.max(-90, Math.min(90, ev.gamma));
      }
      // Fallback, falls kein DeviceMotion vorhanden:
      if (!hasMotion) {
        if (typeof ev.gamma === 'number') rawTiltX = ev.gamma;
        if (typeof ev.beta  === 'number') rawTiltY = ev.beta;
      }
    });

    // Laser-Button
    laserBtn.addEventListener('touchstart', e => {
      e.preventDefault();
      drawing = true;
      sentStart = false;

      // Filter auf aktuellen Zustand setzen
      filtTiltX = rawTiltX; filtTiltY = rawTiltY; filtGamma = rawGamma;
      // Nullpunkte merken
      zeroTiltX = filtTiltX; zeroTiltY = filtTiltY; zeroGamma = filtGamma;
    }, { passive:false });

    laserBtn.addEventListener('touchend', e => {
      e.preventDefault();
      drawing = false;
      socket.emit('draw-end', { deviceId: socket.id });
    }, { passive:false });

    // ---- Konstant getaktetes Senden + Low-Pass an der Quelle ----
    let lastT = performance.now();
    function loop(tNow) {
      const dt = Math.max(1/120, Math.min(1/20, (tNow - lastT)/1000)); // clamp 8–50 ms
      lastT = tNow;

      // einfacher Low-Pass (Zeitkonstanten klein halten)
      const tauTilt = 0.08; // 80ms
      const aTilt   = dt / (tauTilt + dt);
      filtTiltX += (rawTiltX - filtTiltX) * aTilt;
      filtTiltY += (rawTiltY - filtTiltY) * aTilt;

      const tauG = 0.05; // 50ms
      const aG   = dt / (tauG + dt);
      filtGamma += (rawGamma - filtGamma) * aG;

      if (drawing) {
        // Deltas relativ zum Nullpunkt
        let dX = filtTiltX - zeroTiltX; // links/rechts
        let dY = filtTiltY - zeroTiltY; // vor/zurück
        let dG = filtGamma - zeroGamma; // Roll → Paddle-Winkel

        // Reichweite begrenzen
        dX = Math.max(-maxHor, Math.min(maxHor, dX));
        dY = Math.max(-maxVer, Math.min(maxVer, dY));
        dG = Math.max(-75, Math.min(75, dG)); // angenehmer Bereich

        // Normalisieren auf [0..1]
        const x = 1 - ((dX + maxHor) / (2 * maxHor));
        const y = 1 - ((dY + maxVer) / (2 * maxVer));

        // Sicherheitscheck gegen NaN
        if (isFinite(x) && isFinite(y) && isFinite(dG)) {
          socket.emit('draw', {
            x, y,
            angleDeg: dG,
            deviceId: socket.id,
            color: myColor,
            isStart: !sentStart
          });
          sentStart = true;
        }
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
