<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game</title>
  <style>
    body { margin:0; background:#111; overflow:hidden; }
    canvas { display:block; margin:auto; background:#222; }
    #version { position:absolute; top:10px; left:10px; color:#fff; opacity:0.6; }
  </style>
</head>
<body>
  <div id="version">v1.4 Game</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.on("connect", () => {
      socket.emit("identify", { role:"display", deviceId: null });
    });

    const c   = document.getElementById("canvas"),
          ctx = c.getContext("2d"),
          W   = c.width,
          H   = c.height;

    // Ball‐Objekt mit Grafik
    let ball = { x: W/2, y: H/2, vx: 0, vy: 0, r: 20 };
    const ballImg = new Image();
    let imgLoaded = false;
    ballImg.src = '/ball.png'; // Pfad zur echten Ball-Grafik
    ballImg.onload = () => { imgLoaded = true; };

    const FRICTION     = 0.995,
          BOUNCE       = 0.8,
          HIT_STRENGTH = 0.3,
          PTR_R        = 12,  // Pointer-Radius verkleinert für präzisere Kollisionsprüfung
          PTR_TTL      = 500;

    const pointers = {}; // deviceId → { x,y,px,py,t }

    // Segmentbasierte Kollisionserkennung
    function segmentCollision(p) {
      const ax = p.px, ay = p.py;
      const bx = p.x,  by = p.y;
      const cx = ball.x, cy = ball.y;
      const abx = bx - ax, aby = by - ay;
      const ab2 = abx*abx + aby*aby;
      let tSeg = 0;
      if (ab2 > 0) {
        tSeg = ((cx - ax)*abx + (cy - ay)*aby) / ab2;
        tSeg = Math.max(0, Math.min(1, tSeg));
      }
      const closestX = ax + abx * tSeg;
      const closestY = ay + aby * tSeg;
      const dx = cx - closestX;
      const dy = cy - closestY;
      return Math.hypot(dx,dy) < ball.r + PTR_R;
    }

    socket.on("draw", ({ x, y, deviceId }) => {
      const nx = x * W;
      const ny = y * H;
      if (pointers[deviceId]) {
        pointers[deviceId].px = pointers[deviceId].x;
        pointers[deviceId].py = pointers[deviceId].y;
        pointers[deviceId].x = nx;
        pointers[deviceId].y = ny;
        pointers[deviceId].t = performance.now();
      } else {
        pointers[deviceId] = { x: nx, y: ny, px: nx, py: ny, t: performance.now() };
      }
    });

    function cleanup(now) {
      for (let id in pointers) {
        if (now - pointers[id].t > PTR_TTL) delete pointers[id];
      }
    }

    function update(dt) {
      const now = performance.now();
      cleanup(now);
      // Pointer‑Kollision mit Segment-Test
      for (let id in pointers) {
        const p = pointers[id];
        if (segmentCollision(p)) {
          const ax = p.px, ay = p.py;
          const bx = p.x,  by = p.y;
          const abx = bx - ax, aby = by - ay;
          const ab2 = abx*abx + aby*aby;
          let tSeg = ab2 > 0 ? Math.max(0, Math.min(1, ((ball.x - ax)*abx + (ball.y - ay)*aby)/ab2)) : 0;
          const cx = ax + abx * tSeg;
          const cy = ay + aby * tSeg;
          const dx = ball.x - cx;
          const dy = ball.y - cy;
          const dist = Math.hypot(dx,dy) || 1;
          const nx = dx/dist;
          const ny = dy/dist;
          ball.vx += nx * HIT_STRENGTH;
          ball.vy += ny * HIT_STRENGTH;
        }
      }
      // Bewegung
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;
      // Wand‑Abprall
      if (ball.x - ball.r < 0) { ball.x = ball.r;     ball.vx = -ball.vx * BOUNCE; }
      if (ball.x + ball.r > W) { ball.x = W - ball.r; ball.vx = -ball.vx * BOUNCE; }
      if (ball.y - ball.r < 0) { ball.y = ball.r;     ball.vy = -ball.vy * BOUNCE; }
      if (ball.y + ball.r > H) { ball.y = H - ball.r; ball.vy = -ball.vy * BOUNCE; }
      // Reibung
      ball.vx *= FRICTION;
      ball.vy *= FRICTION;
    }

    function draw() {
      ctx.clearRect(0,0,W,H);
      // Ball (Grafik)
      if (imgLoaded) {
        ctx.drawImage(ballImg, ball.x - ball.r, ball.y - ball.r, ball.r*2, ball.r*2);
      } else {
        ctx.beginPath();
        ctx.fillStyle = '#f90';
        ctx.arc(ball.x, ball.y, ball.r, 0, 2*Math.PI);
        ctx.fill();
      }
      // Pointers
      for (let id in pointers) {
        const p = pointers[id];
        ctx.beginPath();
        ctx.fillStyle = '#0cf';
        ctx.arc(p.x, p.y, PTR_R, 0, 2*Math.PI);
        ctx.fill();
      }
    }

    let last = performance.now();
    (function loop(now) {
      const dt = (now - last) / 16.67;
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    })(last);
  </script>
</body>
</html>
