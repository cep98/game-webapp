<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game</title>
  <style>
    body { margin:0; background:#111; overflow:hidden; }
    canvas { display:block; margin:auto; background:#222; }
    #version { position:absolute; top:10px; left:10px; color:#fff; opacity:0.6; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="version">v1.9 Game</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Verbindung und Identifikation
    const socket = io();
    socket.on("connect", () => {
      socket.emit("identify", { role: "display", deviceId: null });
    });

    // Canvas Setup
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;

    // Ball-Objekt mit Rotation
    const ball = {
      x: W / 2,
      y: H / 2,
      vx: 0,
      vy: 0,
      r: 20,
      angle: 0,
      angularVelocity: 0
    };
    const ballImg = new Image();
    let imgLoaded = false;
    ballImg.src = '/ball.png';
    ballImg.onload = () => { imgLoaded = true; };

    // Physik-Konstanten
    const FRICTION      = 0.995;
    const BOUNCE        = 0.8;
    const HIT_STRENGTH  = 0.01;
    const SPIN_STRENGTH = 0.0005;
    const PTR_R         = 10;
    const PTR_TTL       = 2000;

    // Pointer-Datenhaltung
    const pointers = {};

    // Empfang von Motion-Events
    socket.on("motion", ({ x, y, isDrawing, deviceId }) => {
      if (!isDrawing) return;
      const now = performance.now();
      const nx = x * W;
      const ny = y * H;
      if (pointers[deviceId]) {
        pointers[deviceId].px = pointers[deviceId].x;
        pointers[deviceId].py = pointers[deviceId].y;
      }
      pointers[deviceId] = {
        x: nx,
        y: ny,
        px: pointers[deviceId]?.px || nx,
        py: pointers[deviceId]?.py || ny,
        t: now
      };
    });

    // Alte Pointer bereinigen
    function cleanupPointers(now) {
      for (let id in pointers) {
        if (now - pointers[id].t > PTR_TTL) delete pointers[id];
      }
    }

    // Update-Schritt
    function update(dt) {
      const now = performance.now();
      cleanupPointers(now);

      for (let id in pointers) {
        const p = pointers[id];
        const ax = p.px, ay = p.py;
        const bx = p.x,  by = p.y;
        const dx = bx - ax, dy = by - ay;
        const cx = ball.x, cy = ball.y;
        const ab2 = dx*dx + dy*dy;
        let tSeg = ab2 > 0 ? ((cx - ax)*dx + (cy - ay)*dy) / ab2 : 0;
        tSeg = Math.max(0, Math.min(1, tSeg));
        const closestX = ax + dx * tSeg;
        const closestY = ay + dy * tSeg;
        const dist = Math.hypot(ball.x - closestX, ball.y - closestY);

        if (dist < ball.r + PTR_R) {
          // Linearer Impuls
          const pointerSpeed = Math.hypot(dx, dy);
          const impulse = HIT_STRENGTH * pointerSpeed;
          const nx = (ball.x - closestX) / (dist || 1);
          const ny = (ball.y - closestY) / (dist || 1);
          ball.vx += nx * impulse;
          ball.vy += ny * impulse;

          // Tangentialer Spin
          const tx = -ny;
          const ty = nx;
          const tangential = dx * tx + dy * ty;
          ball.angularVelocity += tangential * SPIN_STRENGTH;
        }
      }

      // Bewegung integrieren
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;
      ball.angle += ball.angularVelocity * dt;

      // Kollision mit Wänden
      if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx = -ball.vx * BOUNCE; ball.angularVelocity *= 0.9; }
      if (ball.x + ball.r > W) { ball.x = W - ball.r; ball.vx = -ball.vx * BOUNCE; ball.angularVelocity *= 0.9; }
      if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy = -ball.vy * BOUNCE; ball.angularVelocity *= 0.9; }
      if (ball.y + ball.r > H) { ball.y = H - ball.r; ball.vy = -ball.vy * BOUNCE; ball.angularVelocity *= 0.9; }

      // Dämpfung
      ball.vx *= FRICTION;
      ball.vy *= FRICTION;
      ball.angularVelocity *= FRICTION;
    }

    // Draw-Schritt
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Ball zeichnen
      ctx.save();
      ctx.translate(ball.x, ball.y);
      ctx.rotate(ball.angle);
      if (imgLoaded) {
        ctx.drawImage(ballImg, -ball.r, -ball.r, ball.r * 2, ball.r * 2);
      } else {
        ctx.beginPath(); ctx.fillStyle = '#f90'; ctx.arc(0, 0, ball.r, 0, 2 * Math.PI); ctx.fill();
      }
      ctx.restore();

      // Pointerpunkte drüber
      for (let id in pointers) {
        const p = pointers[id];
        ctx.beginPath();
        ctx.fillStyle = '#0cf';
        ctx.arc(p.x, p.y, PTR_R, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    // Main Loop
    let last = performance.now();
    (function loop(now) {
      const dt = (now - last) / 16.67;
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    })(last);
  </script>
</body>
</html>
