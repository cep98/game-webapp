<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game Display mit Hindernissen</title>
  <style>
    html, body {
      margin:0; padding:0; width:100%; height:100%;
      background:#000; overflow:hidden;
    }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; opacity:0.6; font-size:0.9em;
    }
    canvas {
      display:block; margin:0 auto;
      background:#000;
    }
  </style>
</head>
<body>
  <div id="version">v1.8 Game</div>
  <canvas id="gameCanvas"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  const socket = io();
  socket.on('connect', () => {
    socket.emit('identify',{role:'display',deviceId:socket.id});
    socket.emit('request-settings');
  });

  // Canvas und Maske
  const canvas = document.getElementById('gameCanvas'),
        ctx    = canvas.getContext('2d');
  const maskImage = new Image();
  maskImage.src   = '/mask.png';        // weiße Bereiche = Wände
  const bgImage   = new Image();
  bgImage.src     = '/background.png';  // Hintergrund
  let maskCanvas, maskCtx;
  maskImage.onload = () => {
    canvas.width  = maskImage.width;
    canvas.height = maskImage.height;
    maskCanvas    = document.createElement('canvas');
    maskCanvas.width  = maskImage.width;
    maskCanvas.height = maskImage.height;
    maskCtx = maskCanvas.getContext('2d');
    maskCtx.drawImage(maskImage,0,0);
    // Ball initial
    ball.x = canvas.width/2;
    ball.y = canvas.height/2;
  };
  bgImage.onload = () => {
    // falls bg größer, anpassen
    if (!canvas.width) {
      canvas.width  = bgImage.width;
      canvas.height = bgImage.height;
    }
  };

  // Ball‑Grafiken
  const ballBase   = new Image(); ballBase.src   = '/ball-base.png';
  const ballShadow = new Image(); ballShadow.src = '/ball-shadow.png';

  // Physik‑Defaults
  let smoothing = 0.5;
  const FRICTION         = 0.995,
        ANGULAR_FRICTION = 0.95,
        BOUNCE           = 0.8,
        BASE_STRENGTH    = 0.15,
        SPEED_SCALE      = 0.0002,
        PTR_TTL          = 500,
        PTR_R            = 16;

  // Ball‑State
  let ball = { x:0, y:0, vx:0, vy:0, r:20, angle:0, angularVelocity:0 };

  // Pointers & Farben
  const pointers     = {}; // deviceId -> { sx,sy,px,py,t,pt }
  const deviceColors = {};
  const COLORS       = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6'];
  let colorIndex = 0;

  socket.on('draw', ({x,y,deviceId,color}) => {
    const now  = performance.now();
    const rawX = x * canvas.width, rawY = y * canvas.height;
    if (color) deviceColors[deviceId] = color;
    else if (!deviceColors[deviceId]) deviceColors[deviceId] = COLORS[colorIndex++ % COLORS.length];
    const prev = pointers[deviceId];
    if (prev) {
      const sx = prev.sx + (rawX - prev.sx)*(1-smoothing);
      const sy = prev.sy + (rawY - prev.sy)*(1-smoothing);
      pointers[deviceId] = { sx,sy, px:prev.sx,py:prev.sy, t:now, pt:prev.pt };
    } else {
      pointers[deviceId] = { sx:rawX,sy:rawY, px:rawX,py:rawY, t:now, pt:now };
    }
  });
  socket.on('draw-end', ({deviceId}) => { delete pointers[deviceId]; });
  socket.on('settings', data => { smoothing = data.smoothing; });

  function cleanup(now){
    for (let id in pointers){
      if (now - pointers[id].t > PTR_TTL) delete pointers[id];
    }
  }

  function update(dt){
    const now = performance.now();
    cleanup(now);

    // Zeiger‑Ball‑Kollision wie in v1.5:
    for (let id in pointers){
      const p = pointers[id];
      const dx = p.sx - p.px, dy = p.sy - p.py;
      const segLen = Math.hypot(dx,dy);
      const pixelStep = PTR_R * 0.5;
      let steps = Math.ceil(segLen / pixelStep);
      steps = Math.min(Math.max(steps,1),500);
      let hit = false;
      for (let i=0; i<=steps; i++){
        const t = i/steps;
        const ix = p.px + dx*t, iy = p.py + dy*t;
        if ((ball.x - ix)**2 + (ball.y - iy)**2 <= (ball.r + PTR_R)**2){
          hit = true; break;
        }
      }
      if (hit){
        const midx = p.px + dx*0.5, midy = p.py + dy*0.5;
        let nx = ball.x - midx, ny = ball.y - midy;
        const d = Math.hypot(nx,ny)||1; nx/=d; ny/=d;
        const deltaT = Math.max(p.t - p.pt,1);
        const speed = segLen*1000/deltaT;
        const strength = BASE_STRENGTH + speed*SPEED_SCALE;
        ball.vx += nx*strength;
        ball.vy += ny*strength;
        const rx = midx - ball.x, ry = midy - ball.y;
        const tx = -ny, ty = nx;
        ball.angularVelocity += (rx*ty - ry*tx)*strength*0.005;
      }
      p.pt = p.t;
    }

    // Ball bewegen
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;
    ball.angle += ball.angularVelocity * dt;

    // Wand‑Kollision mit Maske, Ball‑Rand berücksichtigen
    if (maskCtx){
      const cx = Math.round(ball.x), cy = Math.round(ball.y);
      // rechts
      let mx = cx + ball.r, my = cy;
      if (mx>=0 && mx<maskCanvas.width && my>=0 && my<maskCanvas.height){
        const d = maskCtx.getImageData(mx,my,1,1).data;
        if (d[0]>200&&d[1]>200&&d[2]>200){ ball.vx *= -1; }
      }
      // links
      mx = cx - ball.r;
      if (mx>=0){
        const d = maskCtx.getImageData(mx,cy,1,1).data;
        if (d[0]>200&&d[1]>200&&d[2]>200){ ball.vx *= -1; }
      }
      // unten
      mx = cx; my = cy + ball.r;
      if (my<maskCanvas.height){
        const d = maskCtx.getImageData(mx,my,1,1).data;
        if (d[0]>200&&d[1]>200&&d[2]>200){ ball.vy *= -1; }
      }
      // oben
      my = cy - ball.r;
      if (my>=0){
        const d = maskCtx.getImageData(cx,my,1,1).data;
        if (d[0]>200&&d[1]>200&&d[2]>200){ ball.vy *= -1; }
      }
    }

    // Stärke der Reibung
    ball.vx *= FRICTION;
    ball.vy *= FRICTION;
    ball.angularVelocity *= ANGULAR_FRICTION;
  }

  function draw(){
    // Hintergrund
    if (bgImage.complete) ctx.drawImage(bgImage,0,0);
    else ctx.clearRect(0,0,canvas.width,canvas.height);

    // Ball rotierend
    if (ballBase.complete){
      ctx.save();
      ctx.translate(ball.x,ball.y);
      ctx.rotate(ball.angle);
      ctx.drawImage(ballBase,-ball.r,-ball.r,ball.r*2,ball.r*2);
      ctx.restore();
    }
    // Schatten
    if (ballShadow.complete){
      ctx.drawImage(ballShadow,ball.x-ball.r,ball.y-ball.r,ball.r*2,ball.r*2);
    }
    // Pointers
    for (let id in pointers){
      const p = pointers[id];
      ctx.fillStyle = deviceColors[id];
      ctx.beginPath();
      ctx.arc(p.sx,p.sy,PTR_R,0,2*Math.PI);
      ctx.fill();
    }
  }

  // Main‑Loop
  let last = performance.now();
  (function loop(now){
    const dt = (now-last)/16.67;
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  })(last);
  </script>
</body>
</html>
