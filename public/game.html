<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game Display mit verbessertem CCD</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#000; overflow:hidden; }
    #version { position:absolute; top:10px; left:10px; color:#fff; opacity:0.6; font-size:0.9em; }
    canvas { display:block; width:100%; height:100%; background:#000; }
  </style>
</head>
<body>
  <div id="version">v2.0 Game</div>
  <canvas id="gameCanvas"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.on('connect',()=>{
      socket.emit('identify',{role:'display',deviceId:socket.id});
      socket.emit('request-settings');
    });
    const canvas=document.getElementById('gameCanvas'),ctx=canvas.getContext('2d');
    function resize(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;} window.addEventListener('resize',resize);resize();

    // Assets
    const bg=new Image(), mask=new Image(), ballImg=new Image(), ballShadow=new Image();
    bg.src='/background.png'; mask.src='/mask.png'; ballImg.src='/ball-base.png'; ballShadow.src='/ball-shadow.png';
    let maskCanvas,maskCtx;
    mask.onload=()=>{
      maskCanvas=document.createElement('canvas'); maskCanvas.width=mask.width; maskCanvas.height=mask.height;
      maskCtx=maskCanvas.getContext('2d'); maskCtx.drawImage(mask,0,0);
      ball.x=canvas.width/2; ball.y=canvas.height/2;
    };

    // Physics
    const FRICTION=0.995, ANG_FRIC=0.95, BOUNCE=0.8;
    const BASE_STR=0.15, SPEED_SCALE=0.0002;
    const PTR_TTL=500, PTR_R=16;
    let smoothing=0.5;
    let ball={x:0,y:0,vx:0,vy:0,r:20,angle:0,angularVelocity:0};
    const pointers={}, deviceColors={}, COLORS=['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6']; let ci=0;

    // Continuous collision detection for pointer vs ball
    function intersect(px,py, sx,sy, cx,cy, r){
      const dx=sx-px, dy=sy-py;
      const fx=px-cx, fy=py-cy;
      const a=dx*dx+dy*dy, b=2*(fx*dx+fy*dy), c=fx*fx+fy*fy-r*r;
      const D=b*b-4*a*c; if(D<0) return null;
      const t1=(-b-Math.sqrt(D))/(2*a);
      const t2=(-b+Math.sqrt(D))/(2*a);
      if(t1>=0&&t1<=1)return t1;
      if(t2>=0&&t2<=1)return t2;
      return null;
    }

    socket.on('draw',({x,y,deviceId,color})=>{
      const now=performance.now(); const sx=x*canvas.width, sy=y*canvas.height;
      if(color)deviceColors[deviceId]=color; else if(!deviceColors[deviceId])deviceColors[deviceId]=COLORS[ci++%COLORS.length];
      const p=pointers[deviceId];
      if(p) pointers[deviceId]={sx,sy,px:p.sx,py:p.sy,t:now,pt:p.pt}; else pointers[deviceId]={sx,sy,px:sx,py:sy,t:now,pt:now};
    });
    socket.on('draw-end',({deviceId})=>{delete pointers[deviceId]});
    socket.on('settings',d=>smoothing=d.smoothing);

    function cleanup(now){for(let id in pointers) if(now-pointers[id].t>PTR_TTL) delete pointers[id];}

    function update(dt){
      const now=performance.now(); cleanup(now);
      // store old
      let prevX=ball.x, prevY=ball.y;
      // pointer collisions
      for(let id in pointers){
        const p=pointers[id]; const t=intersect(p.px,p.py,p.sx,p.sy,ball.x,ball.y,ball.r+PTR_R);
        if(t!=null){
          const ix=p.px+(p.sx-p.px)*t, iy=p.py+(p.sy-p.py)*t;
          let nx=ball.x-ix, ny=ball.y-iy; const nl=Math.hypot(nx,ny)||1; nx/=nl; ny/=nl;
          const seg=Math.hypot(p.sx-p.px,p.sy-p.py);
          const dtp=Math.max(p.t-p.pt,1);
          const speed=seg*1000/dtp;
          const str=BASE_STR+speed*SPEED_SCALE;
          ball.vx+=nx*str; ball.vy+=ny*str;
          const rx=ix-ball.x, ry=iy-ball.y;
          const tx=-ny, ty=nx;
          ball.angularVelocity+=(rx*ty-ry*tx)*str*0.005;
          p.pt=p.t;
        }
      }
      // integrate
      ball.x+=ball.vx*dt; ball.y+=ball.vy*dt; ball.angle+=ball.angularVelocity*dt;
      // mask edge sampling to prevent penetration
      if(maskCtx){
        const cx=Math.round(ball.x), cy=Math.round(ball.y);
        for(let i=0;i<12;i++){
          const a=i*(Math.PI*2/12);
          const ex=Math.round(cx+Math.cos(a)*ball.r), ey=Math.round(cy+Math.sin(a)*ball.r);
          if(ex>=0&&ey>=0&&ex<maskCanvas.width&&ey<maskCanvas.height){
            const d=maskCtx.getImageData(ex,ey,1,1).data;
            if(d[0]>200&&d[1]>200&&d[2]>200){
              // reflect at normal
              const nx=Math.cos(a), ny=Math.sin(a);
              const vdot=ball.vx*nx+ball.vy*ny;
              ball.vx-=2*vdot*nx; ball.vy-=2*vdot*ny;
              // push out
              ball.x=ex-nx*(ball.r+1); ball.y=ey-ny*(ball.r+1);
              break;
            }
          }
        }
      }
      // wall bounce
      if(ball.x-ball.r<0){ball.x=ball.r;ball.vx*=-BOUNCE;ball.angularVelocity*=-1;}
      if(ball.x+ball.r>canvas.width){ball.x=canvas.width-ball.r;ball.vx*=-BOUNCE;ball.angularVelocity*=-1;}
      if(ball.y-ball.r<0){ball.y=ball.r;ball.vy*=-BOUNCE;ball.angularVelocity*=-1;}
      if(ball.y+ball.r>canvas.height){ball.y=canvas.height-ball.r;ball.vy*=-BOUNCE;ball.angularVelocity*=-1;}
      ball.vx*=FRICTION; ball.vy*=FRICTION; ball.angularVelocity*=ANG_FRIC;
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(bg.complete)ctx.drawImage(bg,0,0,canvas.width,canvas.height);
      if(ballImg.complete){ctx.save();ctx.translate(ball.x,ball.y);ctx.rotate(ball.angle);
        ctx.drawImage(ballImg,-ball.r,-ball.r,ball.r*2,ball.r*2);ctx.restore();}
      if(ballShadow.complete)ctx.drawImage(ballShadow,ball.x-ball.r,ball.y-ball.r,ball.r*2,ball.r*2);
      for(let id in pointers){const p=pointers[id];ctx.fillStyle=deviceColors[id];ctx.beginPath();ctx.arc(p.sx,p.sy,PTR_R,0,2*Math.PI);ctx.fill();}
    }

    let last=performance.now(); (function loop(now){
      const dt=(now-last)/16.67; last=now; update(dt); draw(); requestAnimationFrame(loop);
    })(last);
  </script>
</body>
</html>
