<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game</title>
  <style>
    body { margin:0; background:#000; overflow:hidden; }
    canvas { display:block; margin:auto; background:#000; }
    #version { position:absolute; top:10px; left:10px; color:#fff; opacity:0.6; font-size:0.9em; }
  </style>
</head>
<body>
  <div id="version">v1.2 Game</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket=io();
    socket.on('connect',()=>{ socket.emit('identify',{role:'display'}); socket.emit('request-settings'); });
    const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d'), W=canvas.width, H=canvas.height;
    let ball={x:W/2,y:H/2,vx:0,vy:0,r:20,angle:0,angularVelocity:0}, smoothing=0.5;
    const F=0.995, AF=0.95, B=0.8, BS=0.15, SS=0.0002, TTL=500, PR=16;
    const ballImg=new Image(); ballImg.src='/ball.png'; const pointers={};
    socket.on('settings',d=>smoothing=d.smoothing);
    socket.on('assigned-color',({deviceId,color})=>{ /* unused in game, used in control */ });
    socket.on('draw',({x,y,deviceId})=>{
      const now=performance.now(), rx=x*W, ry=y*H, prev=pointers[deviceId];
      if(prev){ const sx=prev.sx+(rx-prev.sx)*(1-smoothing), sy=prev.sy+(ry-prev.sy)*(1-smoothing);
        pointers[deviceId]={sx,sy,px:prev.sx,py:prev.sy,t:now,pt:prev.pt};
      } else { pointers[deviceId]={sx:rx,sy:ry,px:rx,py:ry,t:now,pt:now}; }
    });
    function cleanup(n){Object.keys(pointers).forEach(id=>{ if(n-pointers[id].t>TTL) delete pointers[id]; });}
    function update(dt){ const now=performance.now(); cleanup(now);
      Object.values(pointers).forEach(p=>{
        const dx=p.sx-p.px, dy=p.sy-p.py, segLen=Math.hypot(dx,dy);
        const pixelStep=Math.max(ball.r/4,1), steps=Math.max(Math.ceil(segLen/pixelStep),10);
        let hit=false;
        for(let i=0;i<=steps;i++){ const t=i/steps, ix=p.px+dx*t, iy=p.py+dy*t; const ddx=ball.x-ix, ddy=ball.y-iy;
          if(ddx*ddx+ddy*ddy<=(ball.r+PR)**2){ hit=true; break; }}
        if(hit){ const midx=p.px+dx*0.5, midy=p.py+dy*0.5; let vx=ball.x-midx, vy=ball.y-midy, len=Math.hypot(vx,vy)||1; vx/=len; vy/=len;
          const dtT=Math.max(p.t-p.pt,1), speed=segLen*1000/dtT, strength=BS+speed*SS;
          ball.vx+=vx*strength; ball.vy+=vy*strength;
          const rx=midx-ball.x, ry=midy-ball.y, tx=-vy, ty=vx;
          ball.angularVelocity+=(rx*ty-ry*tx)*strength*0.005;
        }
        p.pt=p.t;
      });
      ball.x+=ball.vx*dt; ball.y+=ball.vy*dt; ball.angle+=ball.angularVelocity*dt;
      if(ball.x-ball.r<0){ball.x=ball.r;ball.vx=-ball.vx*B;ball.angularVelocity*=-1;} if(ball.x+ball.r>W){ball.x=W-ball.r;ball.vx=-ball.vx*B;ball.angularVelocity*=-1;}
      if(ball.y-ball.r<0){ball.y=ball.r;ball.vy=-ball.vy*B;ball.angularVelocity*=-1;} if(ball.y+ball.r>H){ball.y=H-ball.r;ball.vy=-ball.vy*B;ball.angularVelocity*=-1;}
      ball.vx*=F; ball.vy*=F; ball.angularVelocity*=AF;
    }
    function draw(){ ctx.clearRect(0,0,W,H); if(ballImg.complete){ ctx.save(); ctx.translate(ball.x,ball.y); ctx.rotate(ball.angle); ctx.drawImage(ballImg,-ball.r,-ball.r,ball.r*2,ball.r*2); ctx.restore(); }
      ctx.fillStyle='#0cf'; Object.values(pointers).forEach(p=>{ ctx.beginPath(); ctx.arc(p.sx,p.sy,PR,0,2*Math.PI); ctx.fill(); }); }
    let last=performance.now(); (function loop(now){ const dt=(now-last)/16.67; last=now; update(dt); draw(); requestAnimationFrame(loop); })(last);
  </script>
</body>
</html>
