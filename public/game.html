<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game Display mit Hindernissen (v2.2)</title>
  <style>
    html, body {
      margin:0; padding:0; width:100%; height:100%;
      background:#000; overflow:hidden;
    }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; opacity:0.6; font-size:0.9em;
    }
    canvas {
      display:block; margin:0 auto; background:#000;
    }
  </style>
</head>
<body>
  <div id="version">v2.2 Game</div>
  <canvas id="gameCanvas"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.on('connect', () => {
      socket.emit('identify', { role:'display', deviceId: socket.id });
    });

    const canvas = document.getElementById('gameCanvas'),
          ctx    = canvas.getContext('2d');
    let maskCanvas, maskCtx;

    const bgImage    = new Image(),
          maskImage  = new Image(),
          ballBase   = new Image(),
          ballShadow = new Image();

    bgImage.src    = '/background.png';
    maskImage.src  = '/mask.png';
    ballBase.src   = '/ball-base.png';
    ballShadow.src = '/ball-shadow.png';

    let loaded = 0;
    [bgImage, maskImage].forEach(img => {
      img.onload = () => {
        if (++loaded === 2) {
          canvas.width  = maskImage.width;
          canvas.height = maskImage.height;
          maskCanvas    = document.createElement('canvas');
          maskCanvas.width  = maskImage.width;
          maskCanvas.height = maskImage.height;
          maskCtx = maskCanvas.getContext('2d');
          maskCtx.drawImage(maskImage, 0, 0);
          ball.x = canvas.width / 2;
          ball.y = canvas.height / 2;
        }
      };
    });

    const FRICTION = 0.985;
    const BOUNCE   = 0.8;
    const PTR_R    = 16;

    let ball = { x:0, y:0, vx:0, vy:0, r:20 };

    const pointers = {};
    const deviceColors = {};
    const COLORS = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231'];
    let colorIndex = 0;

    const particles = [];
    function spawnParticles(x, y, color, count = 4) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const speed = 1 + Math.random() * 1.5;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          alpha: 1,
          color,
          sparkle: Math.random() * 30 + 10,
          t: 0
        });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.t += dt;
        p.alpha -= 0.025 * dt;
        if (p.alpha <= 0) particles.splice(i, 1);
      }
    }

    socket.on('draw', ({ x, y, deviceId, color }) => {
      if (!color && !deviceColors[deviceId]) {
        deviceColors[deviceId] = COLORS[colorIndex++ % COLORS.length];
      }
      if (color) deviceColors[deviceId] = color;

      const now = performance.now();
      const px = x * canvas.width;
      const py = y * canvas.height;

      if (!pointers[deviceId]) {
        pointers[deviceId] = { x: px, y: py, px: px, py: py, t: now };
      } else {
        const p = pointers[deviceId];
        p.px = p.x;
        p.py = p.y;
        p.x = px;
        p.y = py;
        p.t = now;
      }
    });

    socket.on('draw-end', ({ deviceId }) => {
      delete pointers[deviceId];
    });

    function update(dt) {
      updateParticles(dt);

      for (let id in pointers) {
        const p = pointers[id];
        const dx = p.x - ball.x;
        const dy = p.y - ball.y;
        const dist = Math.hypot(dx, dy);
        if (dist < PTR_R + ball.r) {
          const nx = dx / dist;
          const ny = dy / dist;
          ball.vx += nx * 0.5;
          ball.vy += ny * 0.5;
          spawnParticles(ball.x + nx * ball.r, ball.y + ny * ball.r, deviceColors[id]);
        }
      }

      ball.vx *= FRICTION;
      ball.vy *= FRICTION;
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Maskenkollision
      let correctionX = 0, correctionY = 0, hitCount = 0;
      for (let i = 0; i < 16; i++) {
        const ang = i * (Math.PI * 2 / 16);
        const ex = Math.round(ball.x + Math.cos(ang) * ball.r);
        const ey = Math.round(ball.y + Math.sin(ang) * ball.r);
        if (ex >= 0 && ey >= 0 && ex < maskCanvas.width && ey < maskCanvas.height) {
          const d = maskCtx.getImageData(ex, ey, 1, 1).data;
          if (d[0] < 200 || d[1] < 200 || d[2] < 200) {
            const nx = Math.cos(ang);
            const ny = Math.sin(ang);
            correctionX += nx;
            correctionY += ny;
            hitCount++;
          }
        }
      }

      if (hitCount > 0) {
        correctionX /= hitCount;
        correctionY /= hitCount;
        const vDotN = ball.vx * correctionX + ball.vy * correctionY;
        if (vDotN < 0) {
          ball.vx -= 2 * vDotN * correctionX;
          ball.vy -= 2 * vDotN * correctionY;
          ball.x += correctionX * 1.5;
          ball.y += correctionY * 1.5;
        }
      }

      if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx *= -BOUNCE; }
      if (ball.x + ball.r > canvas.width) { ball.x = canvas.width - ball.r; ball.vx *= -BOUNCE; }
      if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -BOUNCE; }
      if (ball.y + ball.r > canvas.height) { ball.y = canvas.height - ball.r; ball.vy *= -BOUNCE; }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImage, 0, 0);

      ctx.save();
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 15;
      ctx.shadowOffsetX = -15;
      ctx.shadowOffsetY = 15;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.fill();
      ctx.restore();

      ctx.drawImage(ballBase, ball.x - ball.r, ball.y - ball.r, ball.r * 2, ball.r * 2);
      ctx.drawImage(ballShadow, ball.x - ball.r, ball.y - ball.r, ball.r * 2, ball.r * 2);

      for (let id in pointers) {
        const p = pointers[id];
        const dx = p.x - p.px;
        const dy = p.y - p.py;
        const len = Math.hypot(dx, dy);
        const ux = dx / len || 0;
        const uy = dy / len || 0;

        ctx.strokeStyle = deviceColors[id];
        ctx.lineWidth = PTR_R;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(p.px, p.py);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }

      for (const p of particles) {
        ctx.beginPath();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = Math.floor(p.t) % p.sparkle < p.sparkle / 2 ? p.color : '#fff';
        ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    }

    let last = performance.now();
    requestAnimationFrame(function loop(now) {
      const dt = (now - last) / 16.67;
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
