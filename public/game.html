<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game Display mit Hindernissen (Paddle)</title>
  <style>
    html, body {
      margin:0; padding:0; width:100%; height:100%;
      background:#000; overflow:hidden;
    }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; opacity:0.6; font-size:0.9em;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="version"></div>
  <canvas id="gameCanvas"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.on('connect', () => {
      socket.emit('identify',{ role:'display', deviceId: socket.id });
      socket.emit('request-settings');
    });

    const canvas = document.getElementById('gameCanvas'),
          ctx    = canvas.getContext('2d');
    let maskCanvas, maskCtx;

    const bgImage    = new Image(),
          maskImage  = new Image(),
          ballBase   = new Image(),
          ballShadow = new Image();

    bgImage.src    = '/background.png';
    maskImage.src  = '/mask.png';
    ballBase.src   = '/ball-base.png';
    ballShadow.src = '/ball-shadow.png';

    let loaded=0;
    [bgImage, maskImage].forEach(img=>{
      img.onload = ()=>{
        if (++loaded === 2) {
          // exakt wie Original: Canvas = Maskengröße
          canvas.width  = maskImage.width;
          canvas.height = maskImage.height;
          maskCanvas = document.createElement('canvas');
          maskCanvas.width  = maskImage.width;
          maskCanvas.height = maskImage.height;
          maskCtx = maskCanvas.getContext('2d');
          maskCtx.drawImage(maskImage,0,0);
          ball.x = canvas.width/2;
          ball.y = canvas.height/2;
        }
      };
    });

    let smoothing = 0.5;
    const FRICTION         = 0.995,
          ANGULAR_FRICTION = 0.95,
          BOUNCE_WALL      = 0.8,
          PTR_TTL          = 500;

    // Paddle-Parameter (sanfter)
    const PADDLE_LEN   = 120;
    const PADDLE_THICK = 14;
    const RESTITUTION  = 0.65;  // 1.0 war zu bouncy
    const MAX_REL_N    = 900;   // clamp der rel. Normalgeschwindigkeit (px/s)
    const SPIN_K       = 0.0006;
    const SLOP         = 0.2;

    let ball = { x:0, y:0, vx:0, vy:0, r:20, angle:0, angularVelocity:0 };

    const pointers     = {};
    const deviceColors = {};
    const COLORS       = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6'];
    let colorIndex=0;

    socket.on('draw', ({x,y,rot,deviceId,color})=>{
      if (!canvas.width) return;
      const now  = performance.now();
      const rawX = x * canvas.width, rawY = y * canvas.height;
      if (color) deviceColors[deviceId] = color;
      else if (!deviceColors[deviceId]) deviceColors[deviceId] = COLORS[colorIndex++ % COLORS.length];

      const prev = pointers[deviceId];
      if (prev) {
        const sx = prev.sx + (rawX - prev.sx)*(1-smoothing);
        const sy = prev.sy + (rawY - prev.sy)*(1-smoothing);
        const rotPrev = prev.rot ?? 0;
        let d = (rot ?? 0) - rotPrev; d = ((d + Math.PI) % (2*Math.PI)) - Math.PI; // shortest wrap
        const rotSmoothed = rotPrev + d*(1-smoothing);
        pointers[deviceId] = {
          sx, sy, px: prev.sx, py: prev.sy,
          rot: rotSmoothed, prot: prev.rot ?? rotSmoothed,
          t: now, pt: prev.pt
        };
      } else {
        pointers[deviceId] = {
          sx: rawX, sy: rawY, px: rawX, py: rawY,
          rot: rot || 0, prot: rot || 0,
          t: now, pt: now
        };
      }
    });
    socket.on('draw-end', ({deviceId})=> delete pointers[deviceId]);
    socket.on('settings', data=> smoothing = data.smoothing);

    function cleanup(now){ for (let id in pointers){ if (now - pointers[id].t > PTR_TTL) delete pointers[id]; } }
    function
